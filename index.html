<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DDS to PNG Converter</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@300;500;700&display=swap">
<style>
  :root {
    --bg: #0a0c0f;
    --surface: #0f1318;
    --border: #1e2530;
    --accent: #00e5ff;
    --accent2: #ff6b35;
    --text: #c8d8e8;
    --dim: #4a5568;
    --success: #00ff88;
    --error: #ff4444;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Rajdhani', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }
  body::before {
    content: '';
    position: fixed; inset: 0;
    background-image:
      linear-gradient(rgba(0,229,255,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,229,255,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none; z-index: 0;
  }
  .container {
    position: relative; z-index: 1;
    max-width: 860px; margin: 0 auto;
    padding: 48px 24px 80px;
  }
  .header { text-align: center; margin-bottom: 56px; }
  .header .label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px; letter-spacing: 0.3em;
    color: var(--accent); text-transform: uppercase;
    margin-bottom: 12px; opacity: 0.8;
  }
  .header h1 {
    font-size: clamp(2.4rem, 6vw, 4rem);
    font-weight: 700; letter-spacing: -0.02em; line-height: 1;
    background: linear-gradient(135deg, #fff 0%, var(--accent) 60%, var(--accent2) 100%);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .header .sub {
    margin-top: 14px; font-size: 1rem;
    color: var(--dim); font-weight: 300; letter-spacing: 0.05em;
  }
  .drop-zone {
    border: 1.5px dashed var(--border); border-radius: 4px;
    padding: 56px 32px; text-align: center; cursor: pointer;
    transition: all 0.2s; background: var(--surface);
    position: relative; overflow: hidden;
  }
  .drop-zone::before {
    content: ''; position: absolute; inset: 0;
    background: radial-gradient(ellipse at center, rgba(0,229,255,0.04) 0%, transparent 70%);
    pointer-events: none;
  }
  .drop-zone:hover, .drop-zone.drag-over {
    border-color: var(--accent); background: rgba(0,229,255,0.04);
  }
  .drop-zone.drag-over { transform: scale(1.005); }
  .drop-icon { width: 56px; height: 56px; margin: 0 auto 20px; opacity: 0.6; }
  .drop-title { font-size: 1.3rem; font-weight: 500; letter-spacing: 0.05em; margin-bottom: 8px; }
  .drop-sub { font-size: 0.85rem; color: var(--dim); font-family: 'Share Tech Mono', monospace; }
  .drop-zone input { display: none; }
  .btn-browse {
    margin-top: 24px; display: inline-block;
    padding: 10px 28px; background: transparent;
    border: 1px solid var(--accent); color: var(--accent);
    font-family: 'Share Tech Mono', monospace; font-size: 0.8rem;
    letter-spacing: 0.15em; text-transform: uppercase;
    cursor: pointer; border-radius: 2px; transition: all 0.15s;
  }
  .btn-browse:hover { background: var(--accent); color: var(--bg); }
  .queue { margin-top: 32px; display: flex; flex-direction: column; gap: 10px; }
  .queue-header {
    display: flex; align-items: center;
    justify-content: space-between; margin-bottom: 4px;
  }
  .queue-title {
    font-family: 'Share Tech Mono', monospace; font-size: 11px;
    letter-spacing: 0.2em; color: var(--accent); text-transform: uppercase;
  }
  .queue-count { font-family: 'Share Tech Mono', monospace; font-size: 11px; color: var(--dim); }
  .file-card {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 3px; padding: 14px 18px;
    display: flex; align-items: center; gap: 14px; animation: slideIn 0.2s ease;
  }
  @keyframes slideIn { from{opacity:0;transform:translateY(-8px)} to{opacity:1;transform:translateY(0)} }
  .file-name {
    flex: 1; font-family: 'Share Tech Mono', monospace;
    font-size: 0.82rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
  .file-size { font-size: 0.78rem; color: var(--dim); white-space: nowrap; }
  .badge {
    font-family: 'Share Tech Mono', monospace; font-size: 0.7rem;
    padding: 2px 8px; border-radius: 2px; white-space: nowrap;
  }
  .badge-pending  { border: 1px solid var(--dim);     color: var(--dim); }
  .badge-processing{ border: 1px solid var(--accent);  color: var(--accent); animation: pulse 1s infinite; }
  .badge-done     { border: 1px solid var(--success);  color: var(--success); }
  .badge-error    { border: 1px solid var(--error);    color: var(--error); }
  @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.4} }
  .dl-btn {
    background: var(--success); color: var(--bg); border: none;
    padding: 6px 14px; font-family: 'Share Tech Mono', monospace;
    font-size: 0.72rem; letter-spacing: 0.1em; cursor: pointer;
    border-radius: 2px; transition: opacity 0.15s; white-space: nowrap;
  }
  .dl-btn:hover { opacity: 0.85; }
  .actions { margin-top: 24px; display: flex; gap: 12px; flex-wrap: wrap; }
  .btn-primary {
    flex: 1; min-width: 180px; padding: 14px 28px;
    background: var(--accent); color: var(--bg); border: none;
    font-family: 'Rajdhani', sans-serif; font-size: 1rem;
    font-weight: 700; letter-spacing: 0.12em; text-transform: uppercase;
    cursor: pointer; border-radius: 3px; transition: all 0.15s;
  }
  .btn-primary:hover { opacity: 0.9; transform: translateY(-1px); }
  .btn-primary:disabled { opacity: 0.3; cursor: not-allowed; transform: none; }
  .btn-secondary {
    padding: 14px 24px; background: transparent; color: var(--dim);
    border: 1px solid var(--border); font-family: 'Rajdhani', sans-serif;
    font-size: 1rem; font-weight: 500; letter-spacing: 0.08em;
    cursor: pointer; border-radius: 3px; transition: all 0.15s;
  }
  .btn-secondary:hover { color: var(--text); border-color: var(--dim); }
  .progress-wrap { margin-top: 20px; display: none; }
  .progress-wrap.active { display: block; }
  .progress-bar-bg { height: 3px; background: var(--border); border-radius: 2px; overflow: hidden; }
  .progress-bar {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    transition: width 0.3s; width: 0%;
  }
  .progress-label {
    margin-top: 8px; font-family: 'Share Tech Mono', monospace;
    font-size: 0.75rem; color: var(--dim);
  }
  .info-box {
    margin-top: 48px; border: 1px solid var(--border);
    border-radius: 3px; padding: 20px 24px; background: var(--surface);
  }
  .info-box h3 {
    font-size: 0.85rem; letter-spacing: 0.15em; text-transform: uppercase;
    color: var(--accent); font-family: 'Share Tech Mono', monospace; margin-bottom: 12px;
  }
  .info-box p { font-size: 0.9rem; color: var(--dim); line-height: 1.7; }
  .tag-list { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
  .tag {
    font-family: 'Share Tech Mono', monospace; font-size: 0.72rem;
    color: var(--accent2); border: 1px solid rgba(255,107,53,0.3);
    padding: 3px 10px; border-radius: 2px;
  }
  .footer {
    margin-top: 48px; text-align: center;
    font-family: 'Share Tech Mono', monospace; font-size: 0.72rem;
    color: var(--dim); letter-spacing: 0.1em;
  }
  .footer a { color: var(--accent); text-decoration: none; }
</style>
</head>
<body>
<div class="container">

  <div class="header">
    <div class="label">// texture utility v2.0</div>
    <h1>DDS &rarr; PNG</h1>
    <p class="sub">Convert DirectDraw Surface textures to PNG &mdash; runs entirely in your browser</p>
  </div>

  <div class="drop-zone" id="dropZone">
    <svg class="drop-icon" viewBox="0 0 56 56" fill="none">
      <rect x="4" y="10" width="48" height="36" rx="3" stroke="currentColor" stroke-width="1.5" opacity="0.4"/>
      <path d="M28 38V22M28 22L21 30M28 22L35 30" stroke="var(--accent)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <rect x="14" y="14" width="12" height="9" rx="1" fill="var(--accent)" opacity="0.15" stroke="var(--accent)" stroke-width="1"/>
    </svg>
    <div class="drop-title">Drop .dds files here</div>
    <div class="drop-sub">or click to browse &mdash; multiple files supported</div>
    <button class="btn-browse" onclick="document.getElementById('fileInput').click()">SELECT FILES</button>
    <input type="file" id="fileInput" accept=".dds" multiple>
  </div>

  <div id="queueSection" style="display:none">
    <div class="queue-header">
      <span class="queue-title">// file queue</span>
      <span class="queue-count" id="queueCount">0 files</span>
    </div>
    <div class="queue" id="queue"></div>
    <div class="actions">
      <button class="btn-primary" id="convertBtn" onclick="convertAll()">CONVERT ALL</button>
      <button class="btn-secondary" onclick="clearQueue()">CLEAR</button>
    </div>
    <div class="progress-wrap" id="progressWrap">
      <div class="progress-bar-bg"><div class="progress-bar" id="progressBar"></div></div>
      <div class="progress-label" id="progressLabel">Processing...</div>
    </div>
  </div>

  <div class="info-box">
    <h3>Supported Formats</h3>
    <p>Supports the most common DDS texture formats used in game engines and 3D applications. Processing is done locally &mdash; no files are uploaded to any server.</p>
    <div class="tag-list">
      <span class="tag">DXT1 / BC1</span>
      <span class="tag">DXT3 / BC2</span>
      <span class="tag">DXT5 / BC3</span>
      <span class="tag">BC4 / BC5</span>
      <span class="tag">RGBA8 / BGRA8</span>
      <span class="tag">RGB8</span>
      <span class="tag">A8 / L8</span>
      <span class="tag">DX10 header</span>
    </div>
  </div>

  <div class="footer">
    100% client-side &middot; no upload &middot; no tracking &middot;
    <a href="https://github.com" target="_blank">deploy to github pages</a>
  </div>

</div>
<script>
// ============================================================
// CRC32 (correct 256-entry standard table, verified against zlib)
// ============================================================
const CRC32T=new Uint32Array([
  0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,
  249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,
  498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,
  325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,
  997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,
  901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,
  651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,
  671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,
  1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,
  2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,
  1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,
  1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,
  1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,
  1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,
  1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,
  1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,
  3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,
  3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,
  4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,
  4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,
  3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,
  3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,
  3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,
  3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,
  2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,
  2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,
  2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,
  2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,
  2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,
  2932959818,3654703836,1088359270,936918000,2847714899,3736837829,1202900863,817233897,
  3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,
  3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117
]);

function crc32(buf, off, len){
  let c=0xFFFFFFFF;
  for(let i=0;i<len;i++) c=(c>>>8)^CRC32T[(c^buf[off+i])&0xFF];
  return (c^0xFFFFFFFF)>>>0;
}
function u32be(v){ return [(v>>>24)&0xff,(v>>>16)&0xff,(v>>>8)&0xff,v&0xff]; }

// ============================================================
// DDS constants
// ============================================================
const DDPF_ALPHA=0x2, DDPF_FOURCC=0x4, DDPF_RGB=0x40, DDPF_LUMINANCE=0x20000;
const FOURCC_DXT1=0x31545844, FOURCC_DXT3=0x33545844, FOURCC_DXT5=0x35545844;
const FOURCC_BC4U=0x55344342, FOURCC_BC4S=0x53344342;
const FOURCC_BC5U=0x55354342, FOURCC_BC5S=0x53354342;
const FOURCC_ATI1=0x31495441, FOURCC_ATI2=0x32495441;
const FOURCC_DX10=0x30315844;

// ============================================================
// sRGB LUT: linear uint8 -> sRGB uint8  (IEC 61966-2-1)
// Built once at startup, ~0.3ms
// ============================================================
const L2S=new Uint8Array(256);
(()=>{
  for(let i=0;i<256;i++){
    const l=i/255;
    L2S[i]=Math.round(255*Math.min(1,l<=0.0031308?l*12.92:1.055*Math.pow(l,1/2.4)-0.055));
  }
})();

function applyL2S(d){ // apply only to RGB, skip alpha
  for(let i=0;i<d.length;i+=4){ d[i]=L2S[d[i]]; d[i+1]=L2S[d[i+1]]; d[i+2]=L2S[d[i+2]]; }
}

// ============================================================
// RGB565 unpack
// ============================================================
function unpack565(c){ return [(c>>11&31)*255/31|0,(c>>5&63)*255/63|0,(c&31)*255/31|0]; }

// ============================================================
// Block decoders  (all include bounds check dx/dy)
// ============================================================
function dxt1Block(src,off,dst,bx,by,w,h){
  const c0=src[off]|(src[off+1]<<8), c1=src[off+2]|(src[off+3]<<8);
  const bits=(src[off+4]|(src[off+5]<<8)|(src[off+6]<<16)|(src[off+7]<<24))>>>0;
  const col=[unpack565(c0),unpack565(c1),[],[]];
  if(c0>c1){
    col[2]=col[0].map((v,i)=>(2*v+col[1][i]+1)/3|0);
    col[3]=col[0].map((v,i)=>(v+2*col[1][i]+1)/3|0);
  } else {
    col[2]=col[0].map((v,i)=>(v+col[1][i])>>1);
    col[3]=[0,0,0];
  }
  for(let py=0;py<4;py++) for(let px=0;px<4;px++){
    const dx=bx+px,dy=by+py;
    if(dx>=w||dy>=h) continue;
    const idx=(bits>>>((py*4+px)*2))&3, p=(dy*w+dx)*4;
    dst[p]=col[idx][0]; dst[p+1]=col[idx][1]; dst[p+2]=col[idx][2];
    dst[p+3]=(c0<=c1&&idx===3)?0:255;
  }
}

function dxt3Block(src,off,dst,bx,by,w,h){
  dxt1Block(src,off+8,dst,bx,by,w,h);
  for(let py=0;py<4;py++) for(let px=0;px<4;px++){
    const dx=bx+px,dy=by+py;
    if(dx>=w||dy>=h) continue;
    const ai=py*4+px, ab=src[off+(ai>>1)], a=(ai&1)?(ab>>4):(ab&0xf);
    dst[(dy*w+dx)*4+3]=(a*255/15)|0;
  }
}

function dxt5Alpha(src,off){
  const a0=src[off],a1=src[off+1],tbl=[a0,a1];
  if(a0>a1){ for(let i=2;i<8;i++) tbl[i]=((8-i)*a0+(i-1)*a1)/7|0; }
  else      { for(let i=2;i<6;i++) tbl[i]=((6-i)*a0+(i-1)*a1)/5|0; tbl[6]=0; tbl[7]=255; }
  const lo=(src[off+2]|(src[off+3]<<8)|(src[off+4]<<16)|(src[off+5]<<24))>>>0;
  const hi=(src[off+6]|(src[off+7]<<8))>>>0;
  const out=new Uint8Array(16);
  for(let i=0;i<16;i++){
    const b=i*3;
    let idx;
    if(b<30)       idx=(lo>>>b)&7;
    else if(b===30) idx=((lo>>>30)|((hi&1)<<2))&7;
    else            idx=(hi>>>(b-32))&7;
    out[i]=tbl[idx];
  }
  return out;
}

function dxt5Block(src,off,dst,bx,by,w,h){
  const a=dxt5Alpha(src,off);
  dxt1Block(src,off+8,dst,bx,by,w,h);
  for(let py=0;py<4;py++) for(let px=0;px<4;px++){
    const dx=bx+px,dy=by+py;
    if(dx>=w||dy>=h) continue;
    dst[(dy*w+dx)*4+3]=a[py*4+px];
  }
}

function bc4Block(src,off,dst,bx,by,w,h){
  const a=dxt5Alpha(src,off);
  for(let py=0;py<4;py++) for(let px=0;px<4;px++){
    const dx=bx+px,dy=by+py;
    if(dx>=w||dy>=h) continue;
    const p=(dy*w+dx)*4,v=a[py*4+px];
    dst[p]=v; dst[p+1]=v; dst[p+2]=v; dst[p+3]=255;
  }
}

function bc5Block(src,off,dst,bx,by,w,h){
  const r=dxt5Alpha(src,off), g=dxt5Alpha(src,off+8);
  for(let py=0;py<4;py++) for(let px=0;px<4;px++){
    const dx=bx+px,dy=by+py;
    if(dx>=w||dy>=h) continue;
    const p=(dy*w+dx)*4;
    dst[p]=r[py*4+px]; dst[p+1]=g[py*4+px]; dst[p+2]=128; dst[p+3]=255;
    // B=128 reconstructs correct Z for normal maps: Z = sqrt(1 - R^2 - G^2)
  }
}

// ============================================================
// Mask helpers (uncompressed formats)
// ============================================================
function maskShift(m){ if(!m) return 0; let s=0,v=m; while(!(v&1)){v>>>=1;s++;} return s; }
function maskMax(m){
  if(!m) return 255;
  let v=m>>>maskShift(m),b=0; while(v){b+=v&1;v>>>=1;} return (1<<b)-1;
}

// ============================================================
// Main DDS decoder
// Returns { data:Uint8ClampedArray, width, height, isSRGB, isDataMap }
// isDataMap = true for BC4/BC5/normal/roughness (skip gamma)
// ============================================================
function decodeDDS(buffer){
  const view=new DataView(buffer), bytes=new Uint8Array(buffer);

  if(view.getUint32(0,true)!==0x20534444) throw new Error('Not a valid DDS file');
  // Relaxed header check: some old tools write size != 124
  const hdrSize=view.getUint32(4,true);
  if(hdrSize!==124&&hdrSize!==128) throw new Error('Unexpected DDS header size: '+hdrSize);

  const height=view.getUint32(12,true), width=view.getUint32(16,true);
  if(!width||!height||width>16384||height>16384) throw new Error('Invalid dimensions: '+width+'x'+height);

  const pfOff=76;
  const pfFlags=view.getUint32(pfOff+4,true);
  const fourCC =view.getUint32(pfOff+8,true);
  const rgbBC  =view.getUint32(pfOff+12,true);
  const rMask  =view.getUint32(pfOff+16,true)>>>0;
  const gMask  =view.getUint32(pfOff+20,true)>>>0;
  const bMask  =view.getUint32(pfOff+24,true)>>>0;
  const aMask  =view.getUint32(pfOff+28,true)>>>0;

  const isDX10=(pfFlags&DDPF_FOURCC)&&fourCC===FOURCC_DX10;
  const dataOff=isDX10?148:128;
  const src=bytes.subarray(dataOff);
  const dst=new Uint8ClampedArray(width*height*4);
  const bw=Math.ceil(width/4)|0; // block columns

  let isSRGB=false, isDataMap=false;

  if(pfFlags&DDPF_FOURCC){
    if(fourCC===FOURCC_DXT1){
      for(let by=0;by<height;by+=4) for(let bx=0;bx<width;bx+=4)
        dxt1Block(src,(((by>>2)*bw+(bx>>2))*8)|0,dst,bx,by,width,height);
    } else if(fourCC===FOURCC_DXT3){
      for(let by=0;by<height;by+=4) for(let bx=0;bx<width;bx+=4)
        dxt3Block(src,(((by>>2)*bw+(bx>>2))*16)|0,dst,bx,by,width,height);
    } else if(fourCC===FOURCC_DXT5){
      for(let by=0;by<height;by+=4) for(let bx=0;bx<width;bx+=4)
        dxt5Block(src,(((by>>2)*bw+(bx>>2))*16)|0,dst,bx,by,width,height);
    } else if(fourCC===FOURCC_ATI1||fourCC===FOURCC_BC4U||fourCC===FOURCC_BC4S){
      isDataMap=true; // grayscale data map
      for(let by=0;by<height;by+=4) for(let bx=0;bx<width;bx+=4)
        bc4Block(src,(((by>>2)*bw+(bx>>2))*8)|0,dst,bx,by,width,height);
    } else if(fourCC===FOURCC_ATI2||fourCC===FOURCC_BC5U||fourCC===FOURCC_BC5S){
      isDataMap=true; // normal map / 2-channel data
      for(let by=0;by<height;by+=4) for(let bx=0;bx<width;bx+=4)
        bc5Block(src,(((by>>2)*bw+(bx>>2))*16)|0,dst,bx,by,width,height);
    } else if(isDX10){
      const fmt=view.getUint32(128,true);
      const r=decodeDX10(fmt,src,dst,width,height);
      isSRGB=r.isSRGB; isDataMap=r.isDataMap;
    } else {
      throw new Error('Unsupported FourCC: 0x'+fourCC.toString(16).toUpperCase());
    }
  } else if(pfFlags&DDPF_RGB){
    const bpp=(rgbBC/8)|0;
    if(bpp<1||bpp>4) throw new Error('Invalid bpp: '+bpp);
    const rs=maskShift(rMask),gs=maskShift(gMask),bs=maskShift(bMask),as=maskShift(aMask);
    const rm=maskMax(rMask),gm=maskMax(gMask),bm=maskMax(bMask),am=maskMax(aMask);
    for(let y=0;y<height;y++) for(let x=0;x<width;x++){
      const si=(y*width+x)*bpp; let val=0;
      for(let b=0;b<bpp;b++) val=(val|(src[si+b]<<(b*8)))>>>0;
      const di=(y*width+x)*4;
      dst[di]  =rMask?((val&rMask)>>>rs)*255/rm|0:0;
      dst[di+1]=gMask?((val&gMask)>>>gs)*255/gm|0:0;
      dst[di+2]=bMask?((val&bMask)>>>bs)*255/bm|0:0;
      dst[di+3]=aMask?((val&aMask)>>>as)*255/am|0:255;
    }
  } else if(pfFlags&DDPF_LUMINANCE){
    const bpp=(rgbBC/8)|0||1;
    isDataMap=true;
    for(let y=0;y<height;y++) for(let x=0;x<width;x++){
      const v=src[(y*width+x)*bpp],di=(y*width+x)*4;
      dst[di]=dst[di+1]=dst[di+2]=v; dst[di+3]=255;
    }
  } else if(pfFlags&DDPF_ALPHA){
    isDataMap=true;
    for(let i=0;i<width*height;i++){
      dst[i*4]=dst[i*4+1]=dst[i*4+2]=0; dst[i*4+3]=src[i];
    }
  } else {
    throw new Error('Unsupported pixel format: 0x'+pfFlags.toString(16));
  }

  return {data:dst,width,height,isSRGB,isDataMap};
}

// ============================================================
// DX10 extended format decoder
// Returns { isSRGB, isDataMap }
// ============================================================
function decodeDX10(fmt,src,dst,w,h){
  const n=w*h;
  const srgbSet=new Set([29,71,74,77,91,93]);
  const dataSet=new Set([49,61,79,80,82,83]); // RG8, R8, BC4, BC5
  const bw=Math.ceil(w/4)|0;

  switch(fmt){
    case 28: case 29: // R8G8B8A8_UNORM/_SRGB
      for(let i=0;i<n*4;i++) dst[i]=src[i];
      break;
    case 87: case 91: // B8G8R8A8_UNORM/_SRGB
      for(let i=0;i<n;i++){
        dst[i*4]=src[i*4+2]; dst[i*4+1]=src[i*4+1];
        dst[i*4+2]=src[i*4]; dst[i*4+3]=src[i*4+3];
      }
      break;
    case 88: case 93: // B8G8R8X8_UNORM/_SRGB
      for(let i=0;i<n;i++){
        dst[i*4]=src[i*4+2]; dst[i*4+1]=src[i*4+1];
        dst[i*4+2]=src[i*4]; dst[i*4+3]=255;
      }
      break;
    case 70: case 71: // BC1
      for(let by=0;by<h;by+=4) for(let bx=0;bx<w;bx+=4)
        dxt1Block(src,(((by>>2)*bw+(bx>>2))*8)|0,dst,bx,by,w,h);
      break;
    case 73: case 74: // BC2
      for(let by=0;by<h;by+=4) for(let bx=0;bx<w;bx+=4)
        dxt3Block(src,(((by>>2)*bw+(bx>>2))*16)|0,dst,bx,by,w,h);
      break;
    case 76: case 77: // BC3
      for(let by=0;by<h;by+=4) for(let bx=0;bx<w;bx+=4)
        dxt5Block(src,(((by>>2)*bw+(bx>>2))*16)|0,dst,bx,by,w,h);
      break;
    case 79: case 80: // BC4 UNORM/SNORM
      for(let by=0;by<h;by+=4) for(let bx=0;bx<w;bx+=4)
        bc4Block(src,(((by>>2)*bw+(bx>>2))*8)|0,dst,bx,by,w,h);
      break;
    case 82: case 83: // BC5 UNORM/SNORM
      for(let by=0;by<h;by+=4) for(let bx=0;bx<w;bx+=4)
        bc5Block(src,(((by>>2)*bw+(bx>>2))*16)|0,dst,bx,by,w,h);
      break;
    case 61: // R8_UNORM greyscale
      for(let i=0;i<n;i++){const v=src[i];dst[i*4]=v;dst[i*4+1]=v;dst[i*4+2]=v;dst[i*4+3]=255;}
      break;
    case 49: // R8G8_UNORM
      for(let i=0;i<n;i++){dst[i*4]=src[i*2];dst[i*4+1]=src[i*2+1];dst[i*4+2]=0;dst[i*4+3]=255;}
      break;
    default:
      throw new Error('Unsupported DXGI_FORMAT: '+fmt);
  }
  return {isSRGB:srgbSet.has(fmt), isDataMap:dataSet.has(fmt)};
}

// ============================================================
// PNG encoder with correct sRGB metadata injection
// - Scans the raw PNG to find real end-of-IHDR position
//   (don't hardcode offset=33; Chrome may already inject chunks)
// - Injects sRGB + gAMA only for declared-sRGB sources
// - Does NOT touch data-map textures (BC4/BC5/luminance)
// ============================================================
async function encodeAsPNG(data,width,height,isSRGB){
  const canvas=document.createElement('canvas');
  canvas.width=width; canvas.height=height;
  const ctx=canvas.getContext('2d',{colorSpace:'srgb'});
  let imgData;
  try { imgData=new ImageData(data,width,height,{colorSpace:'srgb'}); }
  catch(_){ imgData=new ImageData(data,width,height); }
  ctx.putImageData(imgData,0,0);

  const rawBlob=await new Promise((res,rej)=>
    canvas.toBlob(b=>b?res(b):rej(new Error('canvas.toBlob returned null')),'image/png')
  );
  if(!isSRGB) return rawBlob; // linear / data maps: no extra metadata needed

  const raw=new Uint8Array(await rawBlob.arrayBuffer());

  // ── Find injection point: right after IHDR chunk ──
  // Scan from byte 8 (after PNG sig) looking for chunk type bytes
  // IHDR = 0x49484452
  let insertAt=33; // default fallback
  if(raw[0]===0x89&&raw[1]===0x50){ // valid PNG sig
    // Byte 8: IHDR length (4 bytes big-endian)
    const ihdrLen=(raw[8]<<24|raw[9]<<16|raw[10]<<8|raw[11])>>>0;
    insertAt=8+4+4+ihdrLen+4; // skip: len(4)+type(4)+data(ihdrLen)+crc(4)
    // Verify we land on a chunk boundary (not another sRGB/cHRM already)
    const nextType=String.fromCharCode(raw[insertAt+4],raw[insertAt+5],raw[insertAt+6],raw[insertAt+7]);
    if(nextType==='sRGB'||nextType==='gAMA'||nextType==='cHRM'){
      // Browser already injected color metadata - return as-is, it's correct
      return rawBlob;
    }
  }

  // ── Build sRGB chunk ──
  const srgbPayload=new Uint8Array([0x73,0x52,0x47,0x42,0]); // "sRGB"+intent=0
  const srgbCRC=crc32(srgbPayload,0,5);
  const srgbChunk=[...u32be(1),...srgbPayload,...u32be(srgbCRC)]; // 13 bytes

  // ── Build gAMA chunk (45455 = sRGB gamma ~1/2.2) ──
  const gamaPayload=new Uint8Array([0x67,0x41,0x4D,0x41,...u32be(45455)]); // "gAMA"+value
  const gamaCRC=crc32(gamaPayload,0,8);
  const gamaChunk=[...u32be(4),...gamaPayload,...u32be(gamaCRC)]; // 16 bytes

  const extra=new Uint8Array([...srgbChunk,...gamaChunk]);
  const out=new Uint8Array(raw.length+extra.length);
  out.set(raw.subarray(0,insertAt));
  out.set(extra,insertAt);
  out.set(raw.subarray(insertAt),insertAt+extra.length);
  return new Blob([out],{type:'image/png'});
}

// ============================================================
// App state
// ============================================================
const fileMap=new Map();
let idN=0;

const dropZone=document.getElementById('dropZone');
const fileInput=document.getElementById('fileInput');
const queueEl=document.getElementById('queue');
const queueSec=document.getElementById('queueSection');
const queueCount=document.getElementById('queueCount');
const convertBtn=document.getElementById('convertBtn');
const progressWrap=document.getElementById('progressWrap');
const progressBar=document.getElementById('progressBar');
const progressLabel=document.getElementById('progressLabel');

dropZone.addEventListener('dragover',e=>{e.preventDefault();dropZone.classList.add('drag-over');});
dropZone.addEventListener('dragleave',()=>dropZone.classList.remove('drag-over'));
dropZone.addEventListener('drop',e=>{e.preventDefault();dropZone.classList.remove('drag-over');addFiles(e.dataTransfer.files);});
dropZone.addEventListener('click',()=>fileInput.click());
fileInput.addEventListener('change',e=>addFiles(e.target.files));

function addFiles(list){
  for(const f of list){
    if(!f.name.toLowerCase().endsWith('.dds')){alert(f.name+' is not a .dds file');continue;}
    const id='f'+(idN++);
    fileMap.set(id,{id,file:f,status:'pending',blob:null});
    renderCard(id);
  }
  updateUI();
}

function fmtSize(n){return n>1e6?(n/1e6).toFixed(1)+'MB':n>1e3?(n/1e3).toFixed(0)+'KB':n+'B';}

function renderCard(id){
  const e=fileMap.get(id);
  const card=document.createElement('div');
  card.className='file-card'; card.id='card-'+id;
  card.innerHTML=`
    <span class="file-name">${e.file.name}</span>
    <span class="file-size">${fmtSize(e.file.size)}</span>
    <span class="badge badge-pending" id="badge-${id}">PENDING</span>
    <button class="dl-btn" id="dl-${id}" style="display:none" onclick="dlFile('${id}')">&#8595; PNG</button>
  `;
  queueEl.appendChild(card);
}

function setBadge(id,cls,txt){
  const b=document.getElementById('badge-'+id);
  b.className='badge badge-'+cls; b.textContent=txt;
}

function updateUI(){
  const n=fileMap.size;
  queueSec.style.display=n?'block':'none';
  queueCount.textContent=n+' file'+(n!==1?'s':'');
}

function clearQueue(){
  fileMap.clear(); queueEl.innerHTML='';
  progressWrap.classList.remove('active');
  fileInput.value=''; updateUI();
}

async function convertAll(){
  convertBtn.disabled=true;
  const todo=[...fileMap.values()].filter(e=>e.status==='pending'||e.status==='error');
  const total=todo.length;
  if(!total){convertBtn.disabled=false;return;}
  progressWrap.classList.add('active');
  progressBar.style.width='0%';

  for(let i=0;i<todo.length;i++){
    const entry=todo[i];
    setBadge(entry.id,'processing','CONVERTING');
    progressLabel.textContent='['+(i+1)+'/'+total+'] '+entry.file.name;
    await new Promise(r=>setTimeout(r,0)); // yield so UI updates

    try{
      const buf=await entry.file.arrayBuffer();
      const {data,width,height,isSRGB,isDataMap}=decodeDDS(buf);

      // Gamma correction rules:
      // - sRGB format  -> already gamma-encoded, pass through
      // - data map     -> skip gamma (BC4/BC5/luminance/alpha are not color)
      // - linear color -> apply linear->sRGB LUT before export
      if(!isSRGB&&!isDataMap) applyL2S(data);

      const blob=await encodeAsPNG(data,width,height,isSRGB);
      entry.blob=blob; entry.status='done';

      // Update card info
      const sizeEl=document.querySelector('#card-'+entry.id+' .file-size');
      sizeEl.textContent=width+'x'+height+' · '+fmtSize(blob.size);
      const tag=document.createElement('span');
      const isNorm=isDataMap&&!isSRGB;
      tag.style.cssText=isNorm
        ?'border:1px solid #94a3b8;color:#94a3b8;font-family:Share Tech Mono,monospace;font-size:.7rem;padding:2px 8px;border-radius:2px;white-space:nowrap'
        :isSRGB
          ?'border:1px solid #a78bfa;color:#a78bfa;font-family:Share Tech Mono,monospace;font-size:.7rem;padding:2px 8px;border-radius:2px;white-space:nowrap'
          :'border:1px solid #34d399;color:#34d399;font-family:Share Tech Mono,monospace;font-size:.7rem;padding:2px 8px;border-radius:2px;white-space:nowrap';
      tag.textContent=isNorm?'DATA':isSRGB?'sRGB':'LIN>sRGB';
      tag.title=isNorm?'Data map (normal/roughness) - no gamma applied':
                isSRGB?'sRGB source - PNG written with sRGB+gAMA chunks':
                       'Linear source - converted to sRGB for PNG export';
      sizeEl.after(tag);

      setBadge(entry.id,'done','DONE');
      document.getElementById('dl-'+entry.id).style.display='inline-block';
    }catch(err){
      entry.status='error';
      const b=document.getElementById('badge-'+entry.id);
      b.className='badge badge-error'; b.textContent='ERROR'; b.title=err.message;
      console.error('[DDS]',entry.file.name,err);
    }

    progressBar.style.width=((i+1)/total*100)+'%';
    if(i%5===4) await new Promise(r=>setTimeout(r,10));
  }

  const done=[...fileMap.values()].filter(e=>e.status==='done').length;
  const errs=[...fileMap.values()].filter(e=>e.status==='error').length;
  progressLabel.textContent='Done - '+done+'/'+total+' converted'+(errs?' · '+errs+' error(s), hover badge':'');
  convertBtn.disabled=false;
}

function dlFile(id){
  const e=fileMap.get(id);
  if(!e||!e.blob) return;
  const a=document.createElement('a');
  a.href=URL.createObjectURL(e.blob);
  a.download=e.file.name.replace(/\.dds$/i,'.png');
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href),1000);
}
</script>
</body>
</html>
