<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DDS to PNG Converter (HW Accelerated)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@300;500;700&display=swap">
<style>
  :root {
    --bg: #0a0c0f;
    --surface: #0f1318;
    --border: #1e2530;
    --accent: #00e5ff;
    --accent2: #ff6b35;
    --text: #c8d8e8;
    --dim: #4a5568;
    --success: #00ff88;
    --error: #ff4444;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Rajdhani', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }
  body::before {
    content: '';
    position: fixed; inset: 0;
    background-image:
      linear-gradient(rgba(0,229,255,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,229,255,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none; z-index: 0;
  }
  .container {
    position: relative; z-index: 1;
    max-width: 860px; margin: 0 auto;
    padding: 48px 24px 80px;
  }
  .header { text-align: center; margin-bottom: 56px; }
  .header .label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px; letter-spacing: 0.3em;
    color: var(--accent); text-transform: uppercase;
    margin-bottom: 12px; opacity: 0.8;
  }
  .header h1 {
    font-size: clamp(2.4rem, 6vw, 4rem);
    font-weight: 700; letter-spacing: -0.02em; line-height: 1;
    background: linear-gradient(135deg, #fff 0%, var(--accent) 60%, var(--accent2) 100%);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .header .sub {
    margin-top: 14px; font-size: 1rem;
    color: var(--dim); font-weight: 300; letter-spacing: 0.05em;
  }
  .drop-zone {
    border: 1.5px dashed var(--border); border-radius: 4px;
    padding: 56px 32px; text-align: center; cursor: pointer;
    transition: all 0.2s; background: var(--surface);
    position: relative; overflow: hidden;
  }
  .drop-zone::before {
    content: ''; position: absolute; inset: 0;
    background: radial-gradient(ellipse at center, rgba(0,229,255,0.04) 0%, transparent 70%);
    pointer-events: none;
  }
  .drop-zone:hover, .drop-zone.drag-over {
    border-color: var(--accent); background: rgba(0,229,255,0.04);
  }
  .drop-zone.drag-over { transform: scale(1.005); }
  .drop-icon { width: 56px; height: 56px; margin: 0 auto 20px; opacity: 0.6; }
  .drop-title { font-size: 1.3rem; font-weight: 500; letter-spacing: 0.05em; margin-bottom: 8px; }
  .drop-sub { font-size: 0.85rem; color: var(--dim); font-family: 'Share Tech Mono', monospace; }
  .drop-zone input { display: none; }
  .btn-browse {
    margin-top: 24px; display: inline-block;
    padding: 10px 28px; background: transparent;
    border: 1px solid var(--accent); color: var(--accent);
    font-family: 'Share Tech Mono', monospace; font-size: 0.8rem;
    letter-spacing: 0.15em; text-transform: uppercase;
    cursor: pointer; border-radius: 2px; transition: all 0.15s;
  }
  .btn-browse:hover { background: var(--accent); color: var(--bg); }
  .queue { margin-top: 32px; display: flex; flex-direction: column; gap: 10px; }
  .queue-header {
    display: flex; align-items: center;
    justify-content: space-between; margin-bottom: 4px;
  }
  .queue-title {
    font-family: 'Share Tech Mono', monospace; font-size: 11px;
    letter-spacing: 0.2em; color: var(--accent); text-transform: uppercase;
  }
  .queue-count { font-family: 'Share Tech Mono', monospace; font-size: 11px; color: var(--dim); }
  .file-card {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 3px; padding: 14px 18px;
    display: flex; align-items: center; gap: 14px; animation: slideIn 0.2s ease;
  }
  @keyframes slideIn { from{opacity:0;transform:translateY(-8px)} to{opacity:1;transform:translateY(0)} }
  .file-name {
    flex: 1; font-family: 'Share Tech Mono', monospace;
    font-size: 0.82rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
  .file-size { font-size: 0.78rem; color: var(--dim); white-space: nowrap; }
  .badge {
    font-family: 'Share Tech Mono', monospace; font-size: 0.7rem;
    padding: 2px 8px; border-radius: 2px; white-space: nowrap;
  }
  .badge-pending  { border: 1px solid var(--dim);     color: var(--dim); }
  .badge-processing{ border: 1px solid var(--accent); color: var(--accent); animation: pulse 1s infinite; }
  .badge-done     { border: 1px solid var(--success); color: var(--success); }
  .badge-error    { border: 1px solid var(--error);   color: var(--error); }
  @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.4} }
  .dl-btn {
    background: var(--success); color: var(--bg); border: none;
    padding: 6px 14px; font-family: 'Share Tech Mono', monospace;
    font-size: 0.72rem; letter-spacing: 0.1em; cursor: pointer;
    border-radius: 2px; transition: opacity 0.15s; white-space: nowrap;
  }
  .dl-btn:hover { opacity: 0.85; }
  .actions { margin-top: 24px; display: flex; gap: 12px; flex-wrap: wrap; }
  .btn-primary {
    flex: 1; min-width: 180px; padding: 14px 28px;
    background: var(--accent); color: var(--bg); border: none;
    font-family: 'Rajdhani', sans-serif; font-size: 1rem;
    font-weight: 700; letter-spacing: 0.12em; text-transform: uppercase;
    cursor: pointer; border-radius: 3px; transition: all 0.15s;
  }
  .btn-primary:hover { opacity: 0.9; transform: translateY(-1px); }
  .btn-primary:disabled { opacity: 0.3; cursor: not-allowed; transform: none; }
  .btn-secondary {
    padding: 14px 24px; background: transparent; color: var(--dim);
    border: 1px solid var(--border); font-family: 'Rajdhani', sans-serif;
    font-size: 1rem; font-weight: 500; letter-spacing: 0.08em;
    cursor: pointer; border-radius: 3px; transition: all 0.15s;
  }
  .btn-secondary:hover { color: var(--text); border-color: var(--dim); }
  .progress-wrap { margin-top: 20px; display: none; }
  .progress-wrap.active { display: block; }
  .progress-bar-bg { height: 3px; background: var(--border); border-radius: 2px; overflow: hidden; }
  .progress-bar {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    transition: width 0.3s; width: 0%;
  }
  .progress-label {
    margin-top: 8px; font-family: 'Share Tech Mono', monospace;
    font-size: 0.75rem; color: var(--dim);
  }
  .info-box {
    margin-top: 48px; border: 1px solid var(--border);
    border-radius: 3px; padding: 20px 24px; background: var(--surface);
  }
  .info-box h3 {
    font-size: 0.85rem; letter-spacing: 0.15em; text-transform: uppercase;
    color: var(--accent); font-family: 'Share Tech Mono', monospace; margin-bottom: 12px;
  }
  .info-box p { font-size: 0.9rem; color: var(--dim); line-height: 1.7; }
  .tag-list { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
  .tag {
    font-family: 'Share Tech Mono', monospace; font-size: 0.72rem;
    color: var(--accent2); border: 1px solid rgba(255,107,53,0.3);
    padding: 3px 10px; border-radius: 2px;
  }
  .footer {
    margin-top: 48px; text-align: center;
    font-family: 'Share Tech Mono', monospace; font-size: 0.72rem;
    color: var(--dim); letter-spacing: 0.1em;
  }
  .footer a { color: var(--accent); text-decoration: none; }
</style>
</head>
<body>
<div class="container">

  <div class="header">
    <div class="label">// texture utility v2.1</div>
    <h1>DDS &rarr; PNG</h1>
    <p class="sub">Convert DirectDraw Surface textures to PNG &mdash; runs entirely in your browser</p>
  </div>

  <div class="drop-zone" id="dropZone">
    <svg class="drop-icon" viewBox="0 0 56 56" fill="none">
      <rect x="4" y="10" width="48" height="36" rx="3" stroke="currentColor" stroke-width="1.5" opacity="0.4"/>
      <path d="M28 38V22M28 22L21 30M28 22L35 30" stroke="var(--accent)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <rect x="14" y="14" width="12" height="9" rx="1" fill="var(--accent)" opacity="0.15" stroke="var(--accent)" stroke-width="1"/>
    </svg>
    <div class="drop-title">Drop .dds files here</div>
    <div class="drop-sub">or click to browse &mdash; multiple files supported</div>
    <button class="btn-browse" onclick="document.getElementById('fileInput').click()">SELECT FILES</button>
    <input type="file" id="fileInput" accept=".dds" multiple>
  </div>

  <div id="queueSection" style="display:none">
    <div class="queue-header">
      <span class="queue-title">// file queue</span>
      <span class="queue-count" id="queueCount">0 files</span>
    </div>
    <div class="queue" id="queue"></div>
    <div class="actions">
      <button class="btn-primary" id="convertBtn" onclick="convertAll()">CONVERT ALL</button>
      <button class="btn-secondary" onclick="clearQueue()">CLEAR</button>
    </div>
    <div class="progress-wrap" id="progressWrap">
      <div class="progress-bar-bg"><div class="progress-bar" id="progressBar"></div></div>
      <div class="progress-label" id="progressLabel">Processing...</div>
    </div>
  </div>

  <div class="info-box">
    <h3>Supported Formats</h3>
    <p>Supports the most common DDS texture formats. Features ultra-fast WebGL GPU Hardware Decoding for instant conversions.</p>
    <div class="tag-list">
      <span class="tag">DXT1 / BC1</span>
      <span class="tag">DXT3 / BC2</span>
      <span class="tag">DXT5 / BC3</span>
      <span class="tag">BC4 / BC5</span>
      <span class="tag">BC7 (HW Decoder)</span>
      <span class="tag">RGBA8 / BGRA8</span>
      <span class="tag">RGB8</span>
      <span class="tag">A8 / L8</span>
      <span class="tag">DX10 header</span>
    </div>
  </div>

  <div class="footer">
    100% client-side &middot; WebGL Hardware Acceleration &middot; no upload
  </div>

</div>
<script>
// ============================================================
// CRC32
// ============================================================
const CRC32T=new Uint32Array([
  0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,
  249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,
  498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,
  325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,
  997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,
  901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,
  651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,
  671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,
  1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,
  2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,
  1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,
  1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,
  1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,
  1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,
  1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,
  1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,
  3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,
  3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,
  4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,
  4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,
  3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,
  3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,
  3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,
  3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,
  2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,
  2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,
  2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,
  2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,
  2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,
  2932959818,3654703836,1088359270,936918000,2847714899,3736837829,1202900863,817233897,
  3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,
  3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117
]);
function crc32(buf, off, len){
  let c=0xFFFFFFFF;
  for(let i=0;i<len;i++) c=(c>>>8)^CRC32T[(c^buf[off+i])&0xFF];
  return (c^0xFFFFFFFF)>>>0;
}
function u32be(v){ return [(v>>>24)&0xff,(v>>>16)&0xff,(v>>>8)&0xff,v&0xff]; }

// ============================================================
// Global render contexts (Prevents Memory Exhaustion / Crashes)
// ============================================================
const glCanvas = document.createElement('canvas');
let gl = null;
try { 
  gl = glCanvas.getContext('webgl2', {preserveDrawingBuffer:true, premultipliedAlpha:false}) || 
       glCanvas.getContext('webgl', {preserveDrawingBuffer:true, premultipliedAlpha:false}); 
} catch(e){}

const encodeCanvas = document.createElement('canvas');
let encodeCtx = null;
try { encodeCtx = encodeCanvas.getContext('2d', {colorSpace:'srgb', willReadFrequently:true}); }
catch(_) { encodeCtx = encodeCanvas.getContext('2d', {willReadFrequently:true}); }

const DDPF_ALPHA=0x2, DDPF_FOURCC=0x4, DDPF_RGB=0x40, DDPF_LUMINANCE=0x20000;
const FOURCC_DXT1=0x31545844, FOURCC_DXT3=0x33545844, FOURCC_DXT5=0x35545844;
const FOURCC_BC4U=0x55344342, FOURCC_BC4S=0x53344342, FOURCC_BC5U=0x55354342, FOURCC_BC5S=0x53354342;
const FOURCC_ATI1=0x31495441, FOURCC_ATI2=0x32495441, FOURCC_DX10=0x30315844;

const L2S=new Uint8Array(256);
(()=>{
  for(let i=0;i<256;i++){
    const l=i/255;
    L2S[i]=Math.round(255*Math.min(1,l<=0.0031308?l*12.92:1.055*Math.pow(l,1/2.4)-0.055));
  }
})();
function applyL2S(d){ for(let i=0;i<d.length;i+=4){ d[i]=L2S[d[i]]; d[i+1]=L2S[d[i+1]]; d[i+2]=L2S[d[i+2]]; } }
function unpack565(c){ return [(c>>11&31)*255/31|0,(c>>5&63)*255/63|0,(c&31)*255/31|0]; }

// ============================================================
// Software Block decoders (Fallback if WebGL is unavailable)
// ============================================================
function dxt1Block(src,off,dst,bx,by,w,h){
  const c0=src[off]|(src[off+1]<<8), c1=src[off+2]|(src[off+3]<<8);
  const bits=(src[off+4]|(src[off+5]<<8)|(src[off+6]<<16)|(src[off+7]<<24))>>>0;
  const col=[unpack565(c0),unpack565(c1),[],[]];
  if(c0>c1){
    col[2]=col[0].map((v,i)=>(2*v+col[1][i]+1)/3|0);
    col[3]=col[0].map((v,i)=>(v+2*col[1][i]+1)/3|0);
  } else {
    col[2]=col[0].map((v,i)=>(v+col[1][i])>>1);
    col[3]=[0,0,0];
  }
  for(let py=0;py<4;py++) for(let px=0;px<4;px++){
    const dx=bx+px,dy=by+py;
    if(dx>=w||dy>=h) continue;
    const idx=(bits>>>((py*4+px)*2))&3, p=(dy*w+dx)*4;
    dst[p]=col[idx][0]; dst[p+1]=col[idx][1]; dst[p+2]=col[idx][2];
    dst[p+3]=(c0<=c1&&idx===3)?0:255;
  }
}
function dxt3Block(src,off,dst,bx,by,w,h){
  dxt1Block(src,off+8,dst,bx,by,w,h);
  for(let py=0;py<4;py++) for(let px=0;px<4;px++){
    const dx=bx+px,dy=by+py;
    if(dx>=w||dy>=h) continue;
    const ai=py*4+px, ab=src[off+(ai>>1)], a=(ai&1)?(ab>>4):(ab&0xf);
    dst[(dy*w+dx)*4+3]=(a*255/15)|0;
  }
}
function dxt5Alpha(src,off){
  const a0=src[off],a1=src[off+1],tbl=[a0,a1];
  if(a0>a1){ for(let i=2;i<8;i++) tbl[i]=((8-i)*a0+(i-1)*a1)/7|0; }
  else     { for(let i=2;i<6;i++) tbl[i]=((6-i)*a0+(i-1)*a1)/5|0; tbl[6]=0; tbl[7]=255; }
  const lo=(src[off+2]|(src[off+3]<<8)|(src[off+4]<<16)|(src[off+5]<<24))>>>0;
  const hi=(src[off+6]|(src[off+7]<<8))>>>0;
  const out=new Uint8Array(16);
  for(let i=0;i<16;i++){
    const b=i*3; let idx;
    if(b<30)       idx=(lo>>>b)&7;
    else if(b===30) idx=((lo>>>30)|((hi&1)<<2))&7;
    else            idx=(hi>>>(b-32))&7;
    out[i]=tbl[idx];
  }
  return out;
}
function dxt5Block(src,off,dst,bx,by,w,h){
  const a=dxt5Alpha(src,off);
  dxt1Block(src,off+8,dst,bx,by,w,h);
  for(let py=0;py<4;py++) for(let px=0;px<4;px++){
    const dx=bx+px,dy=by+py; if(dx>=w||dy>=h) continue;
    dst[(dy*w+dx)*4+3]=a[py*4+px];
  }
}
function bc4Block(src,off,dst,bx,by,w,h){
  const a=dxt5Alpha(src,off);
  for(let py=0;py<4;py++) for(let px=0;px<4;px++){
    const dx=bx+px,dy=by+py; if(dx>=w||dy>=h) continue;
    const p=(dy*w+dx)*4,v=a[py*4+px];
    dst[p]=v; dst[p+1]=v; dst[p+2]=v; dst[p+3]=255;
  }
}
function bc5Block(src,off,dst,bx,by,w,h){
  const r=dxt5Alpha(src,off), g=dxt5Alpha(src,off+8);
  for(let py=0;py<4;py++) for(let px=0;px<4;px++){
    const dx=bx+px,dy=by+py; if(dx>=w||dy>=h) continue;
    const p=(dy*w+dx)*4;
    dst[p]=r[py*4+px]; dst[p+1]=g[py*4+px]; dst[p+2]=128; dst[p+3]=255;
  }
}
function maskShift(m){ if(!m) return 0; let s=0,v=m; while(!(v&1)){v>>>=1;s++;} return s; }
function maskMax(m){ if(!m) return 255; let v=m>>>maskShift(m),b=0; while(v){b+=v&1;v>>>=1;} return (1<<b)-1; }

// ============================================================
// DDS Parser
// ============================================================
function parseDDS(buffer) {
  const view=new DataView(buffer), bytes=new Uint8Array(buffer);
  if(view.getUint32(0,true)!==0x20534444) throw new Error('Not a valid DDS file');
  const hdrSize=view.getUint32(4,true);
  if(hdrSize!==124&&hdrSize!==128) throw new Error('Unexpected DDS header size: '+hdrSize);

  const height=view.getUint32(12,true), width=view.getUint32(16,true);
  if(!width||!height||width>16384||height>16384) throw new Error('Invalid dimensions: '+width+'x'+height);

  const pfOff=76;
  const pfFlags=view.getUint32(pfOff+4,true);
  const fourCC =view.getUint32(pfOff+8,true);
  const rgbBC  =view.getUint32(pfOff+12,true);
  const rMask  =view.getUint32(pfOff+16,true)>>>0, gMask=view.getUint32(pfOff+20,true)>>>0;
  const bMask  =view.getUint32(pfOff+24,true)>>>0, aMask=view.getUint32(pfOff+28,true)>>>0;

  const isDX10=(pfFlags&DDPF_FOURCC)&&fourCC===FOURCC_DX10;
  const dataOff=isDX10?148:128;
  const src=bytes.subarray(dataOff);

  let format=null, isSRGB=false, isDataMap=false, blockSize=0, bpp=0, isCompressed=false;

  if(pfFlags&DDPF_FOURCC){
    isCompressed = true;
    if(fourCC===FOURCC_DXT1) { format = 'DXT1'; blockSize = 8; }
    else if(fourCC===FOURCC_DXT3) { format = 'DXT3'; blockSize = 16; }
    else if(fourCC===FOURCC_DXT5) { format = 'DXT5'; blockSize = 16; }
    else if(fourCC===FOURCC_ATI1||fourCC===FOURCC_BC4U||fourCC===FOURCC_BC4S) { format = 'BC4'; blockSize = 8; isDataMap = true; }
    else if(fourCC===FOURCC_ATI2||fourCC===FOURCC_BC5U||fourCC===FOURCC_BC5S) { format = 'BC5'; blockSize = 16; isDataMap = true; }
    else if(isDX10){
      const fmt=view.getUint32(128,true);
      switch(fmt){
        case 70: format = 'DXT1'; blockSize = 8; break;
        case 71: format = 'DXT1_SRGB'; blockSize = 8; isSRGB=true; break;
        case 73: format = 'DXT3'; blockSize = 16; break;
        case 74: format = 'DXT3_SRGB'; blockSize = 16; isSRGB=true; break;
        case 76: format = 'DXT5'; blockSize = 16; break;
        case 77: format = 'DXT5_SRGB'; blockSize = 16; isSRGB=true; break;
        case 79: case 80: format = 'BC4'; blockSize = 8; isDataMap = true; break;
        case 82: case 83: format = 'BC5'; blockSize = 16; isDataMap = true; break;
        case 98: format = 'BC7'; blockSize = 16; break;
        case 99: format = 'BC7_SRGB'; blockSize = 16; isSRGB=true; break;
        case 28: format = 'RGBA8'; isCompressed = false; bpp = 4; break;
        case 29: format = 'RGBA8_SRGB'; isCompressed = false; bpp = 4; isSRGB=true; break;
        case 87: format = 'BGRA8'; isCompressed = false; bpp = 4; break;
        case 91: format = 'BGRA8_SRGB'; isCompressed = false; bpp = 4; isSRGB=true; break;
        case 88: format = 'BGRX8'; isCompressed = false; bpp = 4; break;
        case 93: format = 'BGRX8_SRGB'; isCompressed = false; bpp = 4; isSRGB=true; break;
        case 61: format = 'R8'; isCompressed = false; bpp = 1; isDataMap = true; break;
        case 49: format = 'RG8'; isCompressed = false; bpp = 2; isDataMap = true; break;
        default: throw new Error('Unsupported DXGI_FORMAT: '+fmt);
      }
    } else throw new Error('Unsupported FourCC: 0x'+fourCC.toString(16).toUpperCase());
  } else if(pfFlags&DDPF_RGB) {
    bpp=(rgbBC/8)|0;
    if(bpp<1||bpp>4) throw new Error('Invalid bpp: '+bpp);
    format = 'UNCOMPRESSED_MASK'; 
  } else if(pfFlags&DDPF_LUMINANCE) {
    bpp=(rgbBC/8)|0||1;
    format = 'LUMINANCE'; isDataMap = true;
  } else if(pfFlags&DDPF_ALPHA) {
    format = 'ALPHA'; bpp = 1; isDataMap = true;
  } else {
    throw new Error('Unsupported pixel format: 0x'+pfFlags.toString(16));
  }

  let dataSize = 0;
  if(isCompressed) {
    dataSize = (Math.ceil(width/4)|0) * (Math.ceil(height/4)|0) * blockSize;
  } else dataSize = width * height * bpp;
  
  if (dataSize > src.length) throw new Error('DDS data truncated or invalid dimension size.');
  const mip0Data = src.subarray(0, dataSize);

  return { width, height, format, isSRGB, isDataMap, isCompressed, mip0Data, bpp, rMask, gMask, bMask, aMask, src };
}

// ============================================================
// WebGL HW Decoder (Ultra Fast, Zero Freeze)
// ============================================================
function getExt(gl, names) {
  for(const n of names) { const ext = gl.getExtension(n); if(ext) return ext; }
  return null;
}

function decodeWithWebGL(info) {
  if (!gl || !info.isCompressed) return null;
  const maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  if (info.width > maxTexSize || info.height > maxTexSize) return null;
  
  let extStr = [], extConst = '', swizzle = 0.0;
  
  if (info.format.startsWith('DXT1')) {
    extStr = ['WEBGL_compressed_texture_s3tc', 'MOZ_WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc'];
    extConst = 'COMPRESSED_RGBA_S3TC_DXT1_EXT';
  } else if (info.format.startsWith('DXT3')) {
    extStr = ['WEBGL_compressed_texture_s3tc', 'MOZ_WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc'];
    extConst = 'COMPRESSED_RGBA_S3TC_DXT3_EXT';
  } else if (info.format.startsWith('DXT5')) {
    extStr = ['WEBGL_compressed_texture_s3tc', 'MOZ_WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc'];
    extConst = 'COMPRESSED_RGBA_S3TC_DXT5_EXT';
  } else if (info.format === 'BC4') {
    extStr = ['EXT_texture_compression_rgtc', 'WEBGL_compressed_texture_rgtc'];
    extConst = 'COMPRESSED_RED_RGTC1_EXT'; swizzle = 1.0;
  } else if (info.format === 'BC5') {
    extStr = ['EXT_texture_compression_rgtc', 'WEBGL_compressed_texture_rgtc'];
    extConst = 'COMPRESSED_RED_GREEN_RGTC2_EXT'; swizzle = 2.0;
  } else if (info.format.startsWith('BC7')) {
    extStr = ['EXT_texture_compression_bptc', 'WEBGL_compressed_texture_bptc'];
    extConst = 'COMPRESSED_RGBA_BPTC_UNORM_EXT'; // Always process UNORM to get raw byte output
  }
  
  const ext = getExt(gl, extStr);
  if (!ext || typeof ext[extConst] === 'undefined') return null;
  
  try {
    glCanvas.width = info.width; glCanvas.height = info.height;
    gl.viewport(0, 0, info.width, info.height);
    gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT);
    
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    
    gl.compressedTexImage2D(gl.TEXTURE_2D, 0, ext[extConst], info.width, info.height, 0, info.mip0Data);
    
    const vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, 'attribute vec2 p; varying vec2 uv; void main(){ uv=p*0.5+0.5; gl_Position=vec4(p,0.0,1.0); }');
    gl.compileShader(vs);
    
    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, 'precision mediump float; varying vec2 uv; uniform sampler2D t; uniform float sw; void main(){ vec4 c = texture2D(t, uv); if (sw == 1.0) gl_FragColor = vec4(c.r, c.r, c.r, 1.0); else if (sw == 2.0) gl_FragColor = vec4(c.r, c.g, 128.0/255.0, 1.0); else gl_FragColor = c; }');
    gl.compileShader(fs);
    
    const prog = gl.createProgram();
    gl.attachShader(prog, vs); gl.attachShader(prog, fs);
    gl.linkProgram(prog); gl.useProgram(prog);
    
    const quad = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quad);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
    const loc = gl.getAttribLocation(prog, "p");
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
    
    gl.uniform1f(gl.getUniformLocation(prog, "sw"), swizzle);
    gl.uniform1i(gl.getUniformLocation(prog, "t"), 0);
    
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    
    const outData = new Uint8Array(info.width * info.height * 4);
    gl.readPixels(0, 0, info.width, info.height, gl.RGBA, gl.UNSIGNED_BYTE, outData);
    
    gl.deleteTexture(tex); gl.deleteBuffer(quad); gl.deleteProgram(prog); gl.deleteShader(vs); gl.deleteShader(fs);
    return new Uint8ClampedArray(outData.buffer);
  } catch(e) {
    console.warn("WebGL decode failed, falling back to software:", e);
    return null;
  }
}

function decodeSoftware(info) {
  const dst = new Uint8ClampedArray(info.width * info.height * 4);
  const w = info.width, h = info.height, src = info.mip0Data;
  if (info.isCompressed) {
    const bw = Math.ceil(w/4)|0;
    if (info.format.startsWith('DXT1')) {
      for(let by=0;by<h;by+=4) for(let bx=0;bx<w;bx+=4) dxt1Block(src,(((by>>2)*bw+(bx>>2))*8)|0,dst,bx,by,w,h);
    } else if (info.format.startsWith('DXT3')) {
      for(let by=0;by<h;by+=4) for(let bx=0;bx<w;bx+=4) dxt3Block(src,(((by>>2)*bw+(bx>>2))*16)|0,dst,bx,by,w,h);
    } else if (info.format.startsWith('DXT5')) {
      for(let by=0;by<h;by+=4) for(let bx=0;bx<w;bx+=4) dxt5Block(src,(((by>>2)*bw+(bx>>2))*16)|0,dst,bx,by,w,h);
    } else if (info.format === 'BC4') {
      for(let by=0;by<h;by+=4) for(let bx=0;bx<w;bx+=4) bc4Block(src,(((by>>2)*bw+(bx>>2))*8)|0,dst,bx,by,w,h);
    } else if (info.format === 'BC5') {
      for(let by=0;by<h;by+=4) for(let bx=0;bx<w;bx+=4) bc5Block(src,(((by>>2)*bw+(bx>>2))*16)|0,dst,bx,by,w,h);
    } else throw new Error('Software decoding not implemented for ' + info.format + ' (Hardware / WebGL strictly required)');
  } else {
    if (info.format === 'UNCOMPRESSED_MASK') {
      const bpp = info.bpp;
      const rs=maskShift(info.rMask),gs=maskShift(info.gMask),bs=maskShift(info.bMask),as=maskShift(info.aMask);
      const rm=maskMax(info.rMask),gm=maskMax(info.gMask),bm=maskMax(info.bMask),am=maskMax(info.aMask);
      for(let y=0;y<h;y++) for(let x=0;x<w;x++){
        const si=(y*w+x)*bpp; let val=0;
        for(let b=0;b<bpp;b++) val=(val|(src[si+b]<<(b*8)))>>>0;
        const di=(y*w+x)*4;
        dst[di]  =info.rMask?((val&info.rMask)>>>rs)*255/rm|0:0;
        dst[di+1]=info.gMask?((val&info.gMask)>>>gs)*255/gm|0:0;
        dst[di+2]=info.bMask?((val&info.bMask)>>>bs)*255/bm|0:0;
        dst[di+3]=info.aMask?((val&info.aMask)>>>as)*255/am|0:255;
      }
    } else if (info.format === 'LUMINANCE') {
      for(let i=0;i<w*h;i++){ const v=src[i*info.bpp]; dst[i*4]=dst[i*4+1]=dst[i*4+2]=v; dst[i*4+3]=255; }
    } else if (info.format === 'ALPHA') {
      for(let i=0;i<w*h;i++){ dst[i*4]=dst[i*4+1]=dst[i*4+2]=0; dst[i*4+3]=src[i]; }
    } else if (info.format.startsWith('RGBA8')) {
      for(let i=0;i<w*h*4;i++) dst[i]=src[i];
    } else if (info.format.startsWith('BGRA8')) {
      for(let i=0;i<w*h;i++){ dst[i*4]=src[i*4+2]; dst[i*4+1]=src[i*4+1]; dst[i*4+2]=src[i*4]; dst[i*4+3]=src[i*4+3]; }
    } else if (info.format.startsWith('BGRX8')) {
      for(let i=0;i<w*h;i++){ dst[i*4]=src[i*4+2]; dst[i*4+1]=src[i*4+1]; dst[i*4+2]=src[i*4]; dst[i*4+3]=255; }
    } else if (info.format === 'R8') {
      for(let i=0;i<w*h;i++){const v=src[i];dst[i*4]=dst[i*4+1]=dst[i*4+2]=v;dst[i*4+3]=255;}
    } else if (info.format === 'RG8') {
      for(let i=0;i<w*h;i++){dst[i*4]=src[i*2];dst[i*4+1]=src[i*2+1];dst[i*4+2]=0;dst[i*4+3]=255;}
    }
  }
  return dst;
}

function decodeDDS(buffer) {
  const info = parseDDS(buffer);
  let data = decodeWithWebGL(info);
  let usedWebGL = true;
  if (!data) {
    data = decodeSoftware(info);
    usedWebGL = false;
  }
  return { data, width: info.width, height: info.height, isSRGB: info.isSRGB, isDataMap: info.isDataMap, usedWebGL };
}

// ============================================================
// PNG encoder
// ============================================================
async function encodeAsPNG(data,width,height,isSRGB){
  encodeCanvas.width=width; encodeCanvas.height=height;
  let imgData;
  try { imgData=new ImageData(data,width,height,{colorSpace:'srgb'}); }
  catch(_){ imgData=new ImageData(data,width,height); }
  
  if(encodeCtx) encodeCtx.putImageData(imgData,0,0);
  else encodeCanvas.getContext('2d').putImageData(imgData,0,0);

  const rawBlob=await new Promise((res,rej)=>
    encodeCanvas.toBlob(b=>b?res(b):rej(new Error('canvas.toBlob returned null')),'image/png')
  );
  
  // Explicitly clear memory
  encodeCanvas.width=1; encodeCanvas.height=1;
  if(encodeCtx) encodeCtx.clearRect(0,0,1,1);

  if(!isSRGB) return rawBlob; 

  const raw=new Uint8Array(await rawBlob.arrayBuffer());
  let insertAt=33;
  if(raw[0]===0x89&&raw[1]===0x50){ 
    const ihdrLen=(raw[8]<<24|raw[9]<<16|raw[10]<<8|raw[11])>>>0;
    insertAt=8+4+4+ihdrLen+4; 
    const nextType=String.fromCharCode(raw[insertAt+4],raw[insertAt+5],raw[insertAt+6],raw[insertAt+7]);
    if(nextType==='sRGB'||nextType==='gAMA'||nextType==='cHRM') return rawBlob;
  }

  const srgbPayload=new Uint8Array([0x73,0x52,0x47,0x42,0]); 
  const srgbCRC=crc32(srgbPayload,0,5);
  const srgbChunk=[...u32be(1),...srgbPayload,...u32be(srgbCRC)]; 
  const gamaPayload=new Uint8Array([0x67,0x41,0x4D,0x41,...u32be(45455)]); 
  const gamaCRC=crc32(gamaPayload,0,8);
  const gamaChunk=[...u32be(4),...gamaPayload,...u32be(gamaCRC)]; 

  const extra=new Uint8Array([...srgbChunk,...gamaChunk]);
  const out=new Uint8Array(raw.length+extra.length);
  out.set(raw.subarray(0,insertAt));
  out.set(extra,insertAt);
  out.set(raw.subarray(insertAt),insertAt+extra.length);
  return new Blob([out],{type:'image/png'});
}

// ============================================================
// App state
// ============================================================
const fileMap=new Map();
let idN=0;

const dropZone=document.getElementById('dropZone');
const fileInput=document.getElementById('fileInput');
const queueEl=document.getElementById('queue');
const queueSec=document.getElementById('queueSection');
const queueCount=document.getElementById('queueCount');
const convertBtn=document.getElementById('convertBtn');
const progressWrap=document.getElementById('progressWrap');
const progressBar=document.getElementById('progressBar');
const progressLabel=document.getElementById('progressLabel');

dropZone.addEventListener('dragover',e=>{e.preventDefault();dropZone.classList.add('drag-over');});
dropZone.addEventListener('dragleave',()=>dropZone.classList.remove('drag-over'));
dropZone.addEventListener('drop',e=>{e.preventDefault();dropZone.classList.remove('drag-over');addFiles(e.dataTransfer.files);});
dropZone.addEventListener('click',()=>fileInput.click());
fileInput.addEventListener('change',e=>addFiles(e.target.files));

function addFiles(list){
  for(const f of list){
    if(!f.name.toLowerCase().endsWith('.dds')){alert(f.name+' is not a .dds file');continue;}
    const id='f'+(idN++);
    fileMap.set(id,{id,file:f,status:'pending',blob:null});
    renderCard(id);
  }
  updateUI();
}

function fmtSize(n){return n>1e6?(n/1e6).toFixed(1)+'MB':n>1e3?(n/1e3).toFixed(0)+'KB':n+'B';}

function renderCard(id){
  const e=fileMap.get(id);
  const card=document.createElement('div');
  card.className='file-card'; card.id='card-'+id;
  card.innerHTML=`
    <span class="file-name">${e.file.name}</span>
    <span class="file-size">${fmtSize(e.file.size)}</span>
    <span class="badge badge-pending" id="badge-${id}">PENDING</span>
    <button class="dl-btn" id="dl-${id}" style="display:none" onclick="dlFile('${id}')">&#8595; PNG</button>
  `;
  queueEl.appendChild(card);
}

function setBadge(id,cls,txt){
  const b=document.getElementById('badge-'+id);
  if(b) { b.className='badge badge-'+cls; b.textContent=txt; }
}

function updateUI(){
  const n=fileMap.size;
  queueSec.style.display=n?'block':'none';
  queueCount.textContent=n+' file'+(n!==1?'s':'');
}

function clearQueue(){
  fileMap.clear(); queueEl.innerHTML='';
  progressWrap.classList.remove('active');
  fileInput.value=''; updateUI();
}

async function convertAll(){
  convertBtn.disabled=true;
  const todo=[...fileMap.values()].filter(e=>e.status==='pending'||e.status==='error');
  const total=todo.length;
  if(!total){convertBtn.disabled=false;return;}
  progressWrap.classList.add('active');
  progressBar.style.width='0%';

  for(let i=0;i<todo.length;i++){
    const entry=todo[i];
    if(!fileMap.has(entry.id)) continue; // abort if user cleared queue

    setBadge(entry.id,'processing','CONVERTING');
    progressLabel.textContent='['+(i+1)+'/'+total+'] '+entry.file.name;
    
    // Give browser a tick to update UI before intensive ops
    await new Promise(r=>setTimeout(r,10));

    try{
      const buf=await entry.file.arrayBuffer();
      const {data,width,height,isSRGB,isDataMap,usedWebGL} = decodeDDS(buf);

      if(!isSRGB&&!isDataMap) applyL2S(data);

      const blob=await encodeAsPNG(data,width,height,isSRGB);
      
      if(!fileMap.has(entry.id)) continue; 
      
      entry.blob=blob; entry.status='done';

      const sizeEl=document.querySelector('#card-'+entry.id+' .file-size');
      sizeEl.textContent=width+'x'+height+' · '+fmtSize(blob.size);
      
      const tag=document.createElement('span');
      const isNorm=isDataMap&&!isSRGB;
      tag.style.cssText=isNorm
        ?'border:1px solid #94a3b8;color:#94a3b8;font-family:Share Tech Mono,monospace;font-size:.7rem;padding:2px 8px;border-radius:2px;white-space:nowrap'
        :isSRGB
          ?'border:1px solid #a78bfa;color:#a78bfa;font-family:Share Tech Mono,monospace;font-size:.7rem;padding:2px 8px;border-radius:2px;white-space:nowrap'
          :'border:1px solid #34d399;color:#34d399;font-family:Share Tech Mono,monospace;font-size:.7rem;padding:2px 8px;border-radius:2px;white-space:nowrap';
      tag.textContent=isNorm?'DATA':isSRGB?'sRGB':'LIN>sRGB';
      if(usedWebGL) tag.textContent += ' [HW]';
      tag.title=isNorm?'Data map (normal/roughness) - no gamma applied':
                isSRGB?'sRGB source - PNG written with sRGB+gAMA chunks':
                       'Linear source - converted to sRGB for PNG export';
      sizeEl.after(tag);

      setBadge(entry.id,'done','DONE');
      document.getElementById('dl-'+entry.id).style.display='inline-block';
    }catch(err){
      entry.status='error';
      const b=document.getElementById('badge-'+entry.id);
      if(b){ b.className='badge badge-error'; b.textContent='ERROR'; b.title=err.message; }
      console.error('[DDS]',entry.file.name,err);
    }

    progressBar.style.width=((i+1)/total*100)+'%';
  }

  const done=[...fileMap.values()].filter(e=>e.status==='done').length;
  const errs=[...fileMap.values()].filter(e=>e.status==='error').length;
  progressLabel.textContent='Done - '+done+'/'+total+' converted'+(errs?' · '+errs+' error(s), hover badge':'');
  convertBtn.disabled=false;
}

function dlFile(id){
  const e=fileMap.get(id);
  if(!e||!e.blob) return;
  const a=document.createElement('a');
  a.href=URL.createObjectURL(e.blob);
  a.download=e.file.name.replace(/\.dds$/i,'.png');
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href),1000);
}
</script>
</body>
</html>
